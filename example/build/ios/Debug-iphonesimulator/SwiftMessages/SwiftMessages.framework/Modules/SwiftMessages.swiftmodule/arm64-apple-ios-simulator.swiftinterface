// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-experimental-feature OpaqueTypeErasure -enable-bare-slash-regex -module-name SwiftMessages
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Foundation
import QuartzCore
import Swift
@_exported import SwiftMessages
import SwiftUI
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol AccessibleMessage {
  var accessibilityMessage: Swift.String? { get }
  var accessibilityElement: ObjectiveC.NSObject? { get }
  var additionalAccessibilityElements: [ObjectiveC.NSObject]? { get }
}
public typealias AnimationCompletion = (_ completed: Swift.Bool) -> Swift.Void
@_Concurrency.MainActor public protocol AnimationDelegate : AnyObject {
  @_Concurrency.MainActor func hide(animator: any SwiftMessages.Animator)
  @_Concurrency.MainActor func panStarted(animator: any SwiftMessages.Animator)
  @_Concurrency.MainActor func panEnded(animator: any SwiftMessages.Animator)
}
public struct SafeZoneConflicts : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let statusBar: SwiftMessages.SafeZoneConflicts
  public static let sensorNotch: SwiftMessages.SafeZoneConflicts
  public static let homeIndicator: SwiftMessages.SafeZoneConflicts
  public static let overStatusBar: SwiftMessages.SafeZoneConflicts
  public typealias ArrayLiteralElement = SwiftMessages.SafeZoneConflicts
  public typealias Element = SwiftMessages.SafeZoneConflicts
  public typealias RawValue = Swift.Int
}
@_hasMissingDesignatedInitializers public class AnimationContext {
  final public let messageView: UIKit.UIView
  final public let containerView: UIKit.UIView
  final public let safeZoneConflicts: SwiftMessages.SafeZoneConflicts
  final public let interactiveHide: Swift.Bool
  @objc deinit
}
@_Concurrency.MainActor public protocol Animator : AnyObject {
  @_Concurrency.MainActor var delegate: (any SwiftMessages.AnimationDelegate)? { get set }
  @_Concurrency.MainActor func show(context: SwiftMessages.AnimationContext, completion: @escaping SwiftMessages.AnimationCompletion)
  @_Concurrency.MainActor func hide(context: SwiftMessages.AnimationContext, completion: @escaping SwiftMessages.AnimationCompletion)
  @_Concurrency.MainActor var showDuration: Foundation.TimeInterval { get }
  @_Concurrency.MainActor var hideDuration: Foundation.TimeInterval { get }
}
public protocol BackgroundViewable {
  var backgroundView: UIKit.UIView! { get }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class BaseView : UIKit.UIView, SwiftMessages.BackgroundViewable, SwiftMessages.MarginAdjustable {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var backgroundView: UIKit.UIView! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency open func installContentView(_ contentView: UIKit.UIView, insets: UIKit.UIEdgeInsets = UIEdgeInsets.zero)
  @_Concurrency.MainActor @preconcurrency open func installBackgroundView(_ backgroundView: UIKit.UIView, insets: UIKit.UIEdgeInsets = UIEdgeInsets.zero)
  @_Concurrency.MainActor @preconcurrency open func installBackgroundVerticalView(_ backgroundView: UIKit.UIView, insets: UIKit.UIEdgeInsets = UIEdgeInsets.zero)
  @_Concurrency.MainActor @preconcurrency open var tapHandler: ((_ view: SwiftMessages.BaseView) -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func point(inside point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var layoutMarginAdditions: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var respectSafeArea: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var topLayoutMarginAddition: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var leftLayoutMarginAddition: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var bottomLayoutMarginAddition: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var rightLayoutMarginAddition: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var collapseLayoutMarginAdditions: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var bounceAnimationOffset: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency open var backgroundHeight: CoreFoundation.CGFloat? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func updateConstraints()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @objc deinit
}
extension SwiftMessages.BaseView {
  @_Concurrency.MainActor @preconcurrency public func configureDropShadow()
  @_Concurrency.MainActor @preconcurrency public func configureNoDropShadow()
}
extension SwiftMessages.BaseView {
  @_Concurrency.MainActor @preconcurrency public func configureBackgroundView(sideMargin: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func configureBackgroundView(width: CoreFoundation.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class CornerRoundingView : UIKit.UIView {
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var cornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var roundsLeadingCorners: Swift.Bool
  @_Concurrency.MainActor @preconcurrency open var roundedCorners: UIKit.UIRectCorner {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @objc deinit
}
public protocol Identifiable {
  var id: Swift.String { get }
}
public protocol KeyboardTrackingViewDelegate : AnyObject {
  func keyboardTrackingViewWillChange(change: SwiftMessages.KeyboardTrackingView.Change, userInfo: [Swift.AnyHashable : Any])
  func keyboardTrackingViewDidChange(change: SwiftMessages.KeyboardTrackingView.Change, userInfo: [Swift.AnyHashable : Any])
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class KeyboardTrackingView : UIKit.UIView {
  public enum Change {
    case show
    case hide
    case frame
    public static func == (a: SwiftMessages.KeyboardTrackingView.Change, b: SwiftMessages.KeyboardTrackingView.Change) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any SwiftMessages.KeyboardTrackingViewDelegate)?
  @_Concurrency.MainActor @preconcurrency open var isPaused: Swift.Bool {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var topMargin: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency open func willChange(change: SwiftMessages.KeyboardTrackingView.Change, userInfo: [Swift.AnyHashable : Any])
  @_Concurrency.MainActor @preconcurrency open func didChange(change: SwiftMessages.KeyboardTrackingView.Change, userInfo: [Swift.AnyHashable : Any])
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @objc deinit
}
public protocol MarginAdjustable {
  var layoutMarginAdditions: UIKit.UIEdgeInsets { get }
  var collapseLayoutMarginAdditions: Swift.Bool { get set }
  var respectSafeArea: Swift.Bool { get set }
  var bounceAnimationOffset: CoreFoundation.CGFloat { get set }
}
extension SwiftMessages.MarginAdjustable where Self : UIKit.UIView {
  public func defaultMarginAdjustment(context: SwiftMessages.AnimationContext) -> UIKit.UIEdgeInsets
}
public struct MessageGeometryProxy {
  public var size: CoreFoundation.CGSize
  public var safeAreaInsets: SwiftUICore.EdgeInsets
}
@_hasMissingDesignatedInitializers @available(iOS 14.0, *)
@_Concurrency.MainActor @preconcurrency public class MessageHostingView<Content> : UIKit.UIView, SwiftMessages.Identifiable where Content : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency final public let id: Swift.String
  @_Concurrency.MainActor @preconcurrency public init(id: Swift.String, content: Content)
  @_Concurrency.MainActor @preconcurrency public init<Message>(message: Message, @SwiftUICore.ViewBuilder content: @escaping (Message, SwiftMessages.MessageGeometryProxy) -> Content) where Message : SwiftMessages.Identifiable
  @_Concurrency.MainActor @preconcurrency convenience public init<Message>(message: Message) where Content == Message.Content, Message : SwiftMessages.MessageViewConvertible
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToSuperview()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class MessageView : SwiftMessages.BaseView, SwiftMessages.Identifiable, SwiftMessages.AccessibleMessage {
  @_Concurrency.MainActor @preconcurrency open var defaultHaptic: SwiftMessages.SwiftMessages.Haptic?
  @_Concurrency.MainActor @preconcurrency open var buttonTapHandler: ((_ button: UIKit.UIButton) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func point(inside point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency open var titleLabel: UIKit.UILabel?
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency open var bodyLabel: UIKit.UILabel?
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency open var iconImageView: UIKit.UIImageView?
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency open var iconLabel: UIKit.UILabel?
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency open var button: UIKit.UIButton? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency open var id: Swift.String {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var accessibilityPrefix: Swift.String?
  @_Concurrency.MainActor @preconcurrency open var accessibilityMessage: Swift.String? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var accessibilityElement: ObjectiveC.NSObject? {
    get
  }
  @_Concurrency.MainActor @preconcurrency open var additionalAccessibilityElements: [ObjectiveC.NSObject]? {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc deinit
}
extension SwiftMessages.MessageView {
  public enum Layout : Swift.String {
    case messageView
    case cardView
    case tabView
    case statusLine
    case centeredView
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public static func viewFromNib<T>(layout: SwiftMessages.MessageView.Layout, filesOwner: Swift.AnyObject = NSNull.init()) -> T where T : SwiftMessages.MessageView
  @_Concurrency.MainActor @preconcurrency public static func viewFromNib<T>(layout: SwiftMessages.MessageView.Layout, bundle: Foundation.Bundle, filesOwner: Swift.AnyObject = NSNull.init()) -> T where T : SwiftMessages.MessageView
}
extension SwiftMessages.MessageView {
  @_Concurrency.MainActor @preconcurrency public func configureIcon(withSize size: CoreFoundation.CGSize, contentMode: UIKit.UIView.ContentMode? = nil)
}
extension SwiftMessages.MessageView {
  @_Concurrency.MainActor @preconcurrency public func configureTheme(_ theme: SwiftMessages.Theme, iconStyle: SwiftMessages.IconStyle = .default, includeHaptic: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func configureTheme(backgroundColor: UIKit.UIColor, foregroundColor: UIKit.UIColor, iconImage: UIKit.UIImage? = nil, iconText: Swift.String? = nil)
}
extension SwiftMessages.MessageView {
  @_Concurrency.MainActor @preconcurrency public func configureContent(body: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func configureContent(title: Swift.String, body: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func configureContent(title: Swift.String, body: Swift.String, iconImage: UIKit.UIImage)
  @_Concurrency.MainActor @preconcurrency public func configureContent(title: Swift.String, body: Swift.String, iconText: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func configureContent(title: Swift.String?, body: Swift.String?, iconImage: UIKit.UIImage?, iconText: Swift.String?, buttonImage: UIKit.UIImage?, buttonTitle: Swift.String?, buttonTapHandler: ((_ button: UIKit.UIButton) -> Swift.Void)?)
}
@available(iOS 14.0, *)
public protocol MessageViewConvertible : Swift.Equatable, SwiftMessages.Identifiable {
  associatedtype Content : SwiftUICore.View
  func asMessageView() -> Self.Content
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor public class PhysicsAnimation : ObjectiveC.NSObject, SwiftMessages.Animator {
  public enum Placement {
    case top
    case center
    case bottom
    public static func == (a: SwiftMessages.PhysicsAnimation.Placement, b: SwiftMessages.PhysicsAnimation.Placement) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor open var placement: SwiftMessages.PhysicsAnimation.Placement
  @_Concurrency.MainActor open var showDuration: Swift.Double
  @_Concurrency.MainActor open var hideDuration: Swift.Double
  @_Concurrency.MainActor public var panHandler: SwiftMessages.PhysicsPanHandler
  @_Concurrency.MainActor weak public var delegate: (any SwiftMessages.AnimationDelegate)?
  @_Concurrency.MainActor @objc override dynamic public init()
  @_Concurrency.MainActor public func show(context: SwiftMessages.AnimationContext, completion: @escaping SwiftMessages.AnimationCompletion)
  @_Concurrency.MainActor public func hide(context: SwiftMessages.AnimationContext, completion: @escaping SwiftMessages.AnimationCompletion)
  @objc @_Concurrency.MainActor public func adjustMargins()
  @objc deinit
}
@_Concurrency.MainActor open class PhysicsPanHandler {
  @_Concurrency.MainActor public var hideDelay: Swift.Double
  public struct MotionSnapshot {
  }
  @_Concurrency.MainActor final public class State {
    @_Concurrency.MainActor public init(messageView: UIKit.UIView, containerView: UIKit.UIView)
    @_Concurrency.MainActor final public func stop()
    @_Concurrency.MainActor final public var angularVelocity: CoreFoundation.CGFloat {
      get
    }
    @objc deinit
  }
  @_Concurrency.MainActor public var state: SwiftMessages.PhysicsPanHandler.State? {
    get
  }
  @_Concurrency.MainActor public var isOffScreen: Swift.Bool {
    get
  }
  @_Concurrency.MainActor public init()
  @_Concurrency.MainActor public var pan: UIKit.UIPanGestureRecognizer {
    get
  }
  @_Concurrency.MainActor public func configure(context: SwiftMessages.AnimationContext, animator: any SwiftMessages.Animator)
  @objc deinit
}
@available(iOS 14.0, *)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func swiftMessage<Message, MessageContent>(message: SwiftUICore.Binding<Message?>, config: SwiftMessages.SwiftMessages.Config? = nil, swiftMessages: SwiftMessages.SwiftMessages? = nil, @SwiftUICore.ViewBuilder messageContent: @escaping (Message) -> MessageContent) -> some SwiftUICore.View where Message : Swift.Equatable, Message : SwiftMessages.Identifiable, MessageContent : SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func swiftMessage<Message, MessageContent>(message: SwiftUICore.Binding<Message?>, config: SwiftMessages.SwiftMessages.Config? = nil, swiftMessages: SwiftMessages.SwiftMessages? = nil, @SwiftUICore.ViewBuilder messageContent: @escaping (Message, SwiftMessages.MessageGeometryProxy) -> MessageContent) -> some SwiftUICore.View where Message : Swift.Equatable, Message : SwiftMessages.Identifiable, MessageContent : SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func swiftMessage<Message>(message: SwiftUICore.Binding<Message?>, config: SwiftMessages.SwiftMessages.Config? = nil, swiftMessages: SwiftMessages.SwiftMessages? = nil) -> some SwiftUICore.View where Message : SwiftMessages.MessageViewConvertible
  
}
@_Concurrency.MainActor open class SwiftMessages {
  public enum PresentationStyle {
    case top
    case bottom
    case center
    case custom(animator: any SwiftMessages.Animator)
  }
  public enum PresentationContext {
    case automatic
    case window(windowLevel: UIKit.UIWindow.Level)
    case windowScene(any SwiftMessages.WindowScene, windowLevel: UIKit.UIWindow.Level)
    case viewController(UIKit.UIViewController)
    case view(UIKit.UIView)
  }
  public enum Duration {
    case automatic
    case forever
    case seconds(seconds: Foundation.TimeInterval)
    case indefinite(delay: Foundation.TimeInterval, minimum: Foundation.TimeInterval)
  }
  public enum Haptic {
    case success
    case warning
    case error
    public static func == (a: SwiftMessages.SwiftMessages.Haptic, b: SwiftMessages.SwiftMessages.Haptic) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DimMode {
    case none
    case gray(interactive: Swift.Bool)
    case color(color: UIKit.UIColor, interactive: Swift.Bool)
    case blur(style: UIKit.UIBlurEffect.Style, alpha: CoreFoundation.CGFloat, interactive: Swift.Bool)
    public var interactive: Swift.Bool {
      get
    }
    public var modal: Swift.Bool {
      get
    }
  }
  public enum Event {
    case willShow(UIKit.UIView)
    case didShow(UIKit.UIView)
    case willHide(UIKit.UIView)
    case didHide(UIKit.UIView)
    public var view: UIKit.UIView {
      get
    }
    public var id: Swift.String? {
      get
    }
  }
  public typealias EventListener = (SwiftMessages.SwiftMessages.Event) -> Swift.Void
  public struct Config {
    public init()
    public var presentationStyle: SwiftMessages.SwiftMessages.PresentationStyle
    public var presentationContext: SwiftMessages.SwiftMessages.PresentationContext
    public var duration: SwiftMessages.SwiftMessages.Duration
    public var dimMode: SwiftMessages.SwiftMessages.DimMode
    public var haptic: SwiftMessages.SwiftMessages.Haptic?
    public var interactiveHide: Swift.Bool
    public var preferredStatusBarStyle: UIKit.UIStatusBarStyle?
    public var prefersStatusBarHidden: Swift.Bool?
    public var shouldAutorotate: Swift.Bool
    public var ignoreDuplicates: Swift.Bool
    public var eventListeners: [SwiftMessages.SwiftMessages.EventListener]
    public var becomeKeyWindow: Swift.Bool?
    public var dimModeAccessibilityLabel: Swift.String
    @available(iOS 13, *)
    public var overrideUserInterfaceStyle: UIKit.UIUserInterfaceStyle {
      get
      set
    }
    public var windowViewController: ((_ config: SwiftMessages.SwiftMessages.Config) -> SwiftMessages.WindowViewController)?
    public var keyboardTrackingView: SwiftMessages.KeyboardTrackingView?
    public var priority: Swift.Int
  }
  nonisolated public init()
  @_Concurrency.MainActor open func show(config: SwiftMessages.SwiftMessages.Config, view: UIKit.UIView)
  @_Concurrency.MainActor public func show(view: UIKit.UIView)
  public typealias ViewProvider = () -> UIKit.UIView
  nonisolated open func show(config: SwiftMessages.SwiftMessages.Config, viewProvider: @escaping SwiftMessages.SwiftMessages.ViewProvider)
  @_Concurrency.MainActor public func show(viewProvider: @escaping SwiftMessages.SwiftMessages.ViewProvider)
  @_Concurrency.MainActor open func hide(animated: Swift.Bool = true)
  @_Concurrency.MainActor open func hideAll()
  @_Concurrency.MainActor open func hide(id: Swift.String)
  @_Concurrency.MainActor open func hideCounted(id: Swift.String)
  @_Concurrency.MainActor public func count(id: Swift.String) -> Swift.Int
  @_Concurrency.MainActor public func set(count: Swift.Int, for id: Swift.String)
  @_Concurrency.MainActor public var defaultConfig: SwiftMessages.SwiftMessages.Config
  @_Concurrency.MainActor open var pauseBetweenMessages: Swift.Double
  @objc deinit
}
extension SwiftMessages.SwiftMessages {
  @_Concurrency.MainActor public func current<T>() -> T? where T : UIKit.UIView
  @_Concurrency.MainActor public func current<T>(id: Swift.String) -> T? where T : UIKit.UIView
  @_Concurrency.MainActor public func queued<T>(id: Swift.String) -> T? where T : UIKit.UIView
  @_Concurrency.MainActor public func currentOrQueued<T>(id: Swift.String) -> T? where T : UIKit.UIView
}
extension SwiftMessages.SwiftMessages {
  @_Concurrency.MainActor public func hide(animator: any SwiftMessages.Animator)
  @_Concurrency.MainActor public func panStarted(animator: any SwiftMessages.Animator)
  @_Concurrency.MainActor public func panEnded(animator: any SwiftMessages.Animator)
}
extension SwiftMessages.SwiftMessages {
  @_Concurrency.MainActor public class func viewFromNib<T>(_ filesOwner: Swift.AnyObject = NSNull.init()) throws -> T where T : UIKit.UIView
  @_Concurrency.MainActor public class func viewFromNib<T>(named name: Swift.String, filesOwner: Swift.AnyObject = NSNull.init()) throws -> T where T : UIKit.UIView
  @_Concurrency.MainActor public class func viewFromNib<T>(named name: Swift.String, bundle: Foundation.Bundle, filesOwner: Swift.AnyObject = NSNull.init()) throws -> T where T : UIKit.UIView
}
extension SwiftMessages.SwiftMessages {
  nonisolated public static var sharedInstance: SwiftMessages.SwiftMessages {
    get
  }
  @_Concurrency.MainActor public static func show(viewProvider: @escaping SwiftMessages.SwiftMessages.ViewProvider)
  @_Concurrency.MainActor public static func show(config: SwiftMessages.SwiftMessages.Config, viewProvider: @escaping SwiftMessages.SwiftMessages.ViewProvider)
  @_Concurrency.MainActor public static func show(view: UIKit.UIView)
  @_Concurrency.MainActor public static func show(config: SwiftMessages.SwiftMessages.Config, view: UIKit.UIView)
  @_Concurrency.MainActor public static func hide(animated: Swift.Bool = true)
  @_Concurrency.MainActor public static func hideAll()
  @_Concurrency.MainActor public static func hide(id: Swift.String)
  @_Concurrency.MainActor public static func hideCounted(id: Swift.String)
  @_Concurrency.MainActor public static var defaultConfig: SwiftMessages.SwiftMessages.Config {
    get
    set
  }
  @_Concurrency.MainActor public static var pauseBetweenMessages: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor public static func current<T>(id: Swift.String) -> T? where T : UIKit.UIView
  @_Concurrency.MainActor public static func queued<T>(id: Swift.String) -> T? where T : UIKit.UIView
  @_Concurrency.MainActor public static func currentOrQueued<T>(id: Swift.String) -> T? where T : UIKit.UIView
  @_Concurrency.MainActor public static func count(id: Swift.String) -> Swift.Int
  @_Concurrency.MainActor public static func set(count: Swift.Int, for id: Swift.String)
}
public struct SwiftMessagesHideAction {
  public init()
  @_Concurrency.MainActor public func callAsFunction(animated: Swift.Bool)
}
extension SwiftUICore.EnvironmentValues {
  public var swiftMessagesHide: SwiftMessages.SwiftMessagesHideAction {
    get
    set
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class SwiftMessagesSegue : UIKit.UIStoryboardSegue {
  public enum Layout {
    case topMessage
    case bottomMessage
    case topCard
    case topTab
    case bottomCard
    case bottomTab
    case centered
    public static func == (a: SwiftMessages.SwiftMessagesSegue.Layout, b: SwiftMessages.SwiftMessagesSegue.Layout) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Containment {
    case content
    case background
    case backgroundVertical
    public static func == (a: SwiftMessages.SwiftMessagesSegue.Containment, b: SwiftMessages.SwiftMessagesSegue.Containment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var presentationStyle: SwiftMessages.SwiftMessages.PresentationStyle {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var dimMode: SwiftMessages.SwiftMessages.DimMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var duration: SwiftMessages.SwiftMessages.Duration {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var interactiveHide: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var eventListeners: [SwiftMessages.SwiftMessages.EventListener] {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var overrideModalPresentationStyle: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var messageView: SwiftMessages.BaseView
  @_Concurrency.MainActor @preconcurrency public var containerView: SwiftMessages.CornerRoundingView
  @_Concurrency.MainActor @preconcurrency public var containment: SwiftMessages.SwiftMessagesSegue.Containment
  @_Concurrency.MainActor @preconcurrency public var keyboardTrackingView: SwiftMessages.KeyboardTrackingView? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func perform()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(identifier: Swift.String?, source: UIKit.UIViewController, destination: UIKit.UIViewController)
  @objc deinit
}
extension SwiftMessages.SwiftMessagesSegue {
  @_Concurrency.MainActor @preconcurrency public func configure(layout: SwiftMessages.SwiftMessagesSegue.Layout)
}
extension SwiftMessages.SwiftMessagesSegue : UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func animationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController, source: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func animationController(forDismissed dismissed: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
}
public enum Theme {
  case info
  case success
  case warning
  case error
  public static func == (a: SwiftMessages.Theme, b: SwiftMessages.Theme) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Icon : Swift.String {
  case error
  case warning
  case success
  case info
  case errorLight
  case warningLight
  case successLight
  case infoLight
  case errorSubtle
  case warningSubtle
  case successSubtle
  case infoSubtle
  public var image: UIKit.UIImage {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum IconStyle {
  case `default`
  case light
  case subtle
  case none
  public func image(theme: SwiftMessages.Theme) -> UIKit.UIImage?
  public static func == (a: SwiftMessages.IconStyle, b: SwiftMessages.IconStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor public class TopBottomAnimation : ObjectiveC.NSObject, SwiftMessages.Animator {
  @_Concurrency.MainActor weak public var delegate: (any SwiftMessages.AnimationDelegate)?
  @_Concurrency.MainActor final public let style: SwiftMessages.TopBottomAnimationStyle
  @_Concurrency.MainActor public var showDuration: Swift.Double
  @_Concurrency.MainActor public var hideDuration: Swift.Double
  @_Concurrency.MainActor public var springDamping: CoreFoundation.CGFloat
  @_Concurrency.MainActor public var closeSpeedThreshold: CoreFoundation.CGFloat
  @_Concurrency.MainActor public var closePercentThreshold: CoreFoundation.CGFloat
  @_Concurrency.MainActor public var closeAbsoluteThreshold: CoreFoundation.CGFloat
  @_Concurrency.MainActor public var panGestureRecognizer: UIKit.UIPanGestureRecognizer {
    get
  }
  @_Concurrency.MainActor public init(style: SwiftMessages.TopBottomAnimationStyle)
  @_Concurrency.MainActor public func show(context: SwiftMessages.AnimationContext, completion: @escaping SwiftMessages.AnimationCompletion)
  @_Concurrency.MainActor public func hide(context: SwiftMessages.AnimationContext, completion: @escaping SwiftMessages.AnimationCompletion)
  @objc @_Concurrency.MainActor public func adjustMargins()
  @objc deinit
}
public enum TopBottomAnimationStyle {
  case top
  case bottom
  public static func == (a: SwiftMessages.TopBottomAnimationStyle, b: SwiftMessages.TopBottomAnimationStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIEdgeInsets {
  public static func + (left: UIKit.UIEdgeInsets, right: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
  public static func - (left: UIKit.UIEdgeInsets, right: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
}
public class Weak<T> where T : AnyObject {
  weak public var value: T?
  public init(value: T?)
  @objc deinit
}
public protocol WindowScene {
}
@available(iOS 13.0, *)
extension UIKit.UIWindowScene : SwiftMessages.WindowScene {
}
@objc @_Concurrency.MainActor @preconcurrency open class WindowViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var shouldAutorotate: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc convenience dynamic public init()
  @_Concurrency.MainActor @preconcurrency public init(config: SwiftMessages.SwiftMessages.Config)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @objc deinit
}
extension SwiftMessages.KeyboardTrackingView.Change : Swift.Equatable {}
extension SwiftMessages.KeyboardTrackingView.Change : Swift.Hashable {}
extension SwiftMessages.MessageView.Layout : Swift.Equatable {}
extension SwiftMessages.MessageView.Layout : Swift.Hashable {}
extension SwiftMessages.MessageView.Layout : Swift.RawRepresentable {}
extension SwiftMessages.PhysicsAnimation : Swift.Sendable {}
extension SwiftMessages.PhysicsAnimation.Placement : Swift.Equatable {}
extension SwiftMessages.PhysicsAnimation.Placement : Swift.Hashable {}
extension SwiftMessages.PhysicsPanHandler : Swift.Sendable {}
extension SwiftMessages.PhysicsPanHandler.State : Swift.Sendable {}
extension SwiftMessages.SwiftMessages : Swift.Sendable {}
extension SwiftMessages.SwiftMessages : SwiftMessages.AnimationDelegate {}
extension SwiftMessages.SwiftMessages.Haptic : Swift.Equatable {}
extension SwiftMessages.SwiftMessages.Haptic : Swift.Hashable {}
extension SwiftMessages.SwiftMessagesSegue.Layout : Swift.Equatable {}
extension SwiftMessages.SwiftMessagesSegue.Layout : Swift.Hashable {}
extension SwiftMessages.SwiftMessagesSegue.Containment : Swift.Equatable {}
extension SwiftMessages.SwiftMessagesSegue.Containment : Swift.Hashable {}
extension SwiftMessages.Theme : Swift.Equatable {}
extension SwiftMessages.Theme : Swift.Hashable {}
extension SwiftMessages.Icon : Swift.Equatable {}
extension SwiftMessages.Icon : Swift.Hashable {}
extension SwiftMessages.Icon : Swift.RawRepresentable {}
extension SwiftMessages.IconStyle : Swift.Equatable {}
extension SwiftMessages.IconStyle : Swift.Hashable {}
extension SwiftMessages.TopBottomAnimation : Swift.Sendable {}
extension SwiftMessages.TopBottomAnimationStyle : Swift.Equatable {}
extension SwiftMessages.TopBottomAnimationStyle : Swift.Hashable {}
